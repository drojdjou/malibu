/* --- --- [Version] --- --- */

/**
 *	@const Framework
 *	@description autogenerated with build script, holds current verison info
 *	@property {string} version - the version 
 *	@property {string} build - the  build number
 *	@property {string} date - the date of the build
 */
// DO NOT EDIT. Updated from version.json
var Framework = {"version":"4","build":192,"date":"2018-08-29T23:02:28.745Z"}

/* --- --- [Simplrz] --- --- */

/**
 *	@namespace Simplrz
 *
 *	@description Feature detection utility.
 *
 *	<p><h2>Using Simplrz</h2>
 *
 *	<p>Simplr is initialized at startup and all test are done immediately. 
 *	The results of the tests are stored in boolean variables listed below. 
 *	Overtime new features are added and some old ones can be discarded, 
 *	so be sure to check the docs from time to time.
 *
 *	<blockquote>
 *	<h5>Note on detecting some CSS features</h5>
 *
 *	<p>After reading this (https://github.com/zamiang/detect-css3-3d-transform)
 *	I realized detecting css3d transforms is unreliable. But also - we don't really need it
 *	because typically the only browser we need to support that doesn't do css 3d transforms
 *	is IE9 and IE8 so why not do some good old browser sniffing?
 *
 *	<p>As a reminder: IE9 - only 2d transforms, no transitions, no animations, IE8 - not even 2d.
 *	</blockquote>
 *
 *	<p>Using Simplrz is very simple in JS, please refer to the first example below. 
 *	Simplrz also sets the names of the properties as classes to the <html> element of the document.
 *	Each class follows the same naming pattern:
 *
 *	<p><code>webgl</code> - if feature is supported the class name is simply the name of the feature.
 *	<p><code>no-webgl</code> - if feature is not supported the class name is  the name of the feature with a <code>no-</code> prefix.
 *
 *	<p>CSS stylesheets can use those classes to use conditiojnal logic. 
 *	Especially handy for example to define hover effects for non-touch only (see example below).
 *
 *	<p>Example that runs the cod in your browser and prints out all the results <a href='http://work.bartekdrozdz.com/malibu/test/simplrz.html'>is here</a>.
 *
 *	@example
if(Simplrz.touch) {
	document.addEventListener('touchstart', onDown);
} else {
	document.addEventListener('mousedown', onDown);
}
 *
 *	@example
// Assuming we use LESS

// This will only work on non-touch screens
.no-touch a:hover {
  text-decoration: underline;
}

#app {
  .webgl-warning {
    display: none;
  }

  // If webgl is not supported, show the warning
  .no-webgl & .webgl-warning {
    display: block;
  } 
}
 */
var Simplrz = (function() {

	var s = {}, classes = ['js']; // Add 'js' class by default (bc if this code runs, JS is enabled, right?)

	var check = function(feature, test) {
		var result = test();
		s[feature] = (result) ? true : false;
		classes.push( (result) ? feature : "no-" + feature );

		document.documentElement.setAttribute("class", classes.join(" "));
	}

	/**
	 *	@member pixelRatio
	 *	@memberof Simplrz
	 *	@description Same vallue as <code>window.devicePixelRatio</code>
	 */
	s.pixelRatio = window.devicePixelRatio || 1;

	var prefix = (function () {

		var styles = "", pre = "", dom = "";

		if(window.getComputedStyle) {
			styles = window.getComputedStyle(document.documentElement, '');
			if(styles) { // Bug in Firefox - this will be null if in iframe and it's set to display:none
				pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || (styles.OLink === '' && ['', 'o']))[1];
				dom = ('WebKit|Moz|MS|O').match(new RegExp('(' + pre + ')', 'i'))[1];
			}
		}

		return {
			dom: dom,
			lowercase: pre,
			css: '-' + pre + '-',
			js: (pre == "") ? "" : pre[0].toUpperCase() + pre.substr(1)
		};
	})();

	/**
	 *	@member prefix
	 *	@memberof Simplrz
	 *	@description whar is the browser vendor prefix (-ms, -webkit, -moz...)
	 *
	 *	@returns {Object} contins several versions of the prefix, see example below.
	 *
	 *	@example
{
	dom: "Webkit",
	lowercase: "webkit,
	css: "-webkit-",
	js: "Webkit"
}
	 */
	s["prefix"] = prefix;
	classes.push(prefix.lowercase);

	s.prefixedProp = function(prop) {
		switch(prefix.lowercase) {
			case "webkit": return "webkit" + prop.charAt(0).toUpperCase() + prop.slice(1);
			case "ms": return "-ms-" + prop;
			case "moz": return "Moz" + prop.charAt(0).toUpperCase() + prop.slice(1);
			default: return prefix.css + prop;
		}
	} 

	// -- BROWSER HACKS BEGIN -- 
	// These properties are for browser specific hack (yes, they are sometimes necessary)
	var ie = (function(){
	    var v = 3, div = document.createElement('div'), all = div.getElementsByTagName('i');
	    while (
	        div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',
	        all[0]
	    ) {
	    	// console.log(div.innerHTML);
	    }
	    return v > 4 ? v : null;
	})();

	// IE 10 doesn't use conditional comments anymore
	if(ie == null) {
		var p = new RegExp("MSIE ([0-9]{1,}[\.0-9]{0,})");
		var ua = navigator.userAgent;
		var m = ua.match(p);
		ie = (m && m.length > 1) ? parseInt(m[1]) : null;
	}

	/**
	 *	@member {Boolean} ie
	 *	@memberof Simplrz
	 *	@description false if browser is not IE, otherwise the version number (8, 9, 10...)
	 */
	s.ie = ie || false;
	classes.push((ie) ? "ie-" + ie : "no-ie");

	/**
	 *	@member {Boolean} firefox
	 *	@memberof Simplrz
	 *	@description True if the device is an iPad.
	 */
	s.firefox = prefix.lowercase == "moz";
	classes.push(s.firefox ? "firefox" : "no-firefox");

	/**
	 *	@member {Boolean} safariDesktop
	 *	@memberof Simplrz
	 *	@description True if the the browser is a Safari on desktop Mac.
	 */
	s.safariDesktop = navigator.userAgent.match(/Safari/) && !navigator.userAgent.match(/Chrome/) && !('ontouchstart' in document);
	classes.push(s.safariDesktop ? "safari-desktop" : "no-safari-desktop");

	// s.ipad7 = navigator.userAgent.match(/iPad;.*CPU.*OS 7_\d/i) || false;
	// classes.push(s.ipad7 ? "ipad7" : "no-ipad7");

	/**
	 *	@member {Boolean} iOS
	 *	@memberof Simplrz
	 *	@description True if the device runs on iOS.
	 */
	s.iOS = /(iPad|iPhone|iPod)/g.test(navigator.userAgent);
	classes.push(s.iOS ? "ios" : "no-ios");

	/**
	 *	@member {Boolean} iPad
	 *	@memberof Simplrz
	 *	@description True if the device is an iPad.
	 */
	s.iPad = (navigator.platform == 'iPad');
	classes.push(s.iPad ? "ipad" : "no-ipad");

	/**
	 *	@member {Boolean} win
	 *	@memberof Simplrz
	 *	@description True if the device is running Windows.
	 */
	s.win = (navigator.platform == 'Win32' || navigator.platform == 'Win64');
	classes.push(s.win ? "win" : "no-win");

	/**
	 *	@member {Boolean} win
	 *	@memberof Simplrz
	 *	@description True if the device is running Windows.
	 */
	s.android = ( navigator.userAgent.toLowerCase().indexOf("android") > -1);
	classes.push(s.android ? "android" : "no-android");

	s.vrbrowser = /(OculusBrowser|Mobile\sVR)/g.test(navigator.userAgent);
	classes.push(s.vrbrowser ? "vrbrowser" : "no-vrbrowser");

	// -- BROWSER HACKS END -- 



	/**
	 *	@member {Boolean} css3d
	 *	@memberof Simplrz
	 *	@description True if CSS 3d transforms are supported.
	 */
	check("css3d", function() {

		if(prefix.lowercase == 'webkit' || prefix.lowercase == 'moz') return true;

		if(prefix.lowercase == 'ms') {
			var div = document.createElement("div");
			div.style[prefix.css + "transform"] = 'translateZ(0px)';
			var cs = window.getComputedStyle(div);
			if(cs) { // Bug in Firefox - this will be null if in iframe and it's set to display:none
				var a = cs.getPropertyValue(prefix.css + "transform");
				return a && a != '' && a != 'none';
			}
		}

		return false;
	});

	/**
	 *	@member {Boolean} csstransitions
	 *	@memberof Simplrz
	 *	@description True if CSS Transitions are supported.
	 */
	check("csstransitions", function() { return !ie || ie >= 10; });

	/**
	 *	@member {Boolean} cssanimations
	 *	@memberof Simplrz
	 *	@description True if CSS Animations are supported.
	 */
	check("cssanimations", function() { return !ie || ie >= 10; });

	/**
	 *	@member {Boolean} css2d
	 *	@memberof Simplrz
	 *	@description True if CSS 2d transforms are supported.
	 */
	check("css2d", function() { return !ie || ie >= 9; });

	/**
	 *	@member {Boolean} touch
	 *	@memberof Simplrz
	 *	@description True if touch events are supported.
	 */
	check("touch", function() {
		return 'ontouchstart' in document && navigator.platform.indexOf("Win") == -1;
	});

	/**
	 *	@member {Boolean} pointer
	 *	@memberof Simplrz
	 *	@description True if pointer API (sort of like touch but different spec, used mostly by MS) is supported.
	 */
	check("pointer", function() {
		return !!window.navigator.pointerEnabled || !!window.navigator.msPointerEnabled;
	});

	/**
	 *	@member {Boolean} canvas
	 *	@memberof Simplrz
	 *	@description True if canvas 2d API is supported.
	 */
	check("canvas", function() {
		try { 
			var canvas = document.createElement('canvas'); 
			return canvas.getContext('2d');
		} catch(e) { 
			return false; 
		}
	});

	/**
	 *	@member {Boolean} history
	 *	@memberof Simplrz
	 *	@description True if the history API is supported.
	 */
	check("history", function() {
		return !!(window.history && history.pushState);
	});

	/**
	 *	@member {Boolean} webrtc
	 *	@memberof Simplrz
	 *	@description True if webrtc is supported.
	 */
	check("webrtc", function() {
		return ('getUserMedia' in navigator || 'webkitGetUserMedia' in navigator);
	});

	/**
	 *	@member {Boolean} webgl
	 *	@memberof Simplrz
	 *	@description True if webgl is supported.
	 */
	check("webgl", function() {
		try { 
			var canvas = document.createElement('canvas'); 
			return !!window.WebGLRenderingContext && 
				(canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
		} catch(e) { 
			return false; 
		} 
	});

	// Flash is dead anyway!
	// check("flash", function() {
	// 	return !!(
	// 		navigator.mimeTypes["application/x-shockwave-flash"] || 
	// 		window.ActiveXObject && new ActiveXObject('ShockwaveFlash.ShockwaveFlash')
	// 	);
	// });

	/**
	 *	@member {Array} classes
	 *	@memberof Simplrz
	 *	@description An array containing all the classes that have been added to the <html> element.
	 */
	s.classes = classes;

	return s;

})();

/* --- --- [Trigger] --- --- */

/**
 *	@class Trigger
 *
 *	@description Trigger is a simple utility used to create events. 
 *	<p>A Trigger can only send one type of event and it will always notify all of its listeners. 
 * 	<p>In order to build a more robust event system, use multiple 
 *	Trigger objects as properties.
 *
 *	@example
// Simple usage for a single type of event
var menuPress = new Trigger();

var menuPressListener = function(params) {
  console.log("menuPress trigger fired");
  // params = whatever was passed to the trigger method (see below)
  console.log(params);
}

menuPress.on(menuPressListener);

// ... then somewhere in the code:
menuPress.trigger({ id: 5 });

// ... and eventually
menuPress.off(menuPressListener);
 *
 *	@example
// If there are multiple events to handle, 
// simply create multiple triggers
var car = {
  engineStarted: new Trigger(),
  brakeApplied: new Trigger(),
  gearChanged: new Trigger()
}
 */
var Trigger = function() {

	var t = {};

	var listeners = [];
	var lock = false;

	var lateTriggers = [];
	var lateRemovals = [];

	/**
	 *	@method on
	 *	@memberof Trigger.prototype
	 *	@param {Function} callback - the function used as callback for the listener
	 *	@param {Object=} context - the context in which to invoke the function
	 *	@description Adds a listener to this trigger
	 */
	t.on = function (callback, context, callOnInit) {
		if(listeners.indexOf(callback) > -1) { return; }
		callback.context = context;
		listeners.push(callback);
		if(callOnInit) callback();
	};

	/**
	 *	@method off
	 *	@memberof Trigger.prototype
	 *	@param {Function} callback - the function used as callback for the listener. 
	 *	Needs to be the same function as passed to the <code>on()</code> when it was being registered.
	 *	@description Removes a listener from this trigger. 
	 *	<p>If the passed callback is not a listener of this trigger, 
	 *	this function will not throw any warnings, it will just return. 
	 *	<p>If this function is called from within a function that is a listener for that trigger, 
	 *	the callback will not be removed until all other listeners are called.
	 */
	t.off = function (callback) {
		var i = listeners.indexOf(callback);

		if(i == -1) return;

		if(lock) {
			lateRemovals.push({ callback: callback });
			return;
		}

		listeners.splice(i, 1);
	};

	/**
	 *	@method trigger
	 *	@memberof Trigger.prototype
	 *	@param {Object=} data - An object specifying the events parameters. All listeners will receive this object as argument.
	 *	@description Fires this trigger passing data as srgument to all listeners.
	 *	<p>If this function is called from within a function that is a listener for that trigger, 
	 *	the trigger will not be fired until all other listeners 
	 *	are called for the previous one.
	 */
	t.trigger = function (data) {

		if(lock) {
			lateTriggers.push({ data: data });
			return;
		}

		lock = true;

		var i = 0, nl = listeners.length;
		while(i < nl) {
			var f = listeners[i];
			f.call(f.context, data);
			i++;
		}
		
		lock = false;

		var d;
		while(d = lateTriggers.shift()) t.trigger(d.data);
		while(d = lateRemovals.shift()) t.off(d.callback);
	};

	return t;

};

/* --- --- [Timer] --- --- */

/**
 *	@class Timer
 *
 *	@description A timer utility used to invoke function once or repeatedly in time.
 *
 *	@param {Boolean} autostart - if true the Timer will start counting time immediately. Otherwise start() needs to be called manually later.
 *	@param {Boolean} autoupdate - if true the Timer will be updating on every frame. Otherwise, update() needs to be called on every frame.
 */
var Timer = function(autostart, autoupdate) {

	var that = this;

	// If frame is longer than 250ms (4 FPS) it will skip it.
	// TODO: what is the logic behind this?
	var MAX_FRAME_TIME = 250;

	var paused = false;

	this.time = 0;
	this.frame = 0;
	this.deltatime = 0;

	var startTime, elapsedTime = 0;

	var tasks = [];

	var trackTask = function(e, i) {
		if(e._time < that.time) {
			if(e._repeat != 0) {
				e.callback(e._time);

				var it = e._interval;
				if(it instanceof Array) e._time += it[0] + Math.random() * (it[1] - it[0]);
				else e._time += it;

				e._repeat--;
			} else {
				setTimeout(that.off, 0, e); // <- is it good enough?
			}
		}
	};

	var run = function() {
		requestAnimationFrame(run);
		that.update();
	}

	/**
	 *	@method pause
	 *	@memberof Timer.prototype
	 *	@description Pauses/resumes the execution of the timer.
	 *	@param {Boolean} p - true to pause, false to resume
	 *	@return {Timer} self, for chaining.
	 */
	this.pause = function(p) {
		paused = p;
		return this;
	}

	/**
	 *	@method paused
	 *	@memberof Timer.prototype
	 *	@description Returns true is timer is paused, false otherwise.
	 */
	this.paused = function() {
		return paused;
	}

	/**
	 *	@method start
	 *	@memberof Timer.prototype
	 *	@description Start the timer manually.
	 *	<p>If autostart was set to false or omitted in the constructor, this function needs to be invoked.	
	 */
	this.start = function() {
		startTime = new Date().getTime(), 
		elapsedTime = 0, 
		that.frame = 0;
		that.time = 0;

		if(autoupdate) run();

		return that;
	}

	/**
	 *	@method update
	 *	@memberof Timer.prototype
	 *	@description Updates the timer.
	 *
	 *	<p>If autoupdate was set to false or omitted in the constructor, 
	 *	this function need to be invoked in a requestAnimationFrame loop or a similar interval.
	 */
	this.update = function() {
		var t = new Date().getTime() - startTime;
		var d = t - elapsedTime;
		elapsedTime = t;

		if(d < MAX_FRAME_TIME && !paused) {
			that.time += d;
			that.frame++;
			that.deltatime = d;
		}

		tasks.forEach(trackTask);
		return that.time;
	}

	/**
	 *	@method onAt
	 *	@memberof Timer.prototype
	 *	@description Executes callback after a delay. All time values in milliseconds.
	 *
	 *	@param {Number} time - when to start (i.e. delay counted from 'now' i.e from when this method is called)
	 *	@param {Function} callback - the callback to be invoked
	 *
	 *	@returns {Object} - an special object that can be used to remove the task later.
	 */
	this.onAt = function(_time, callback) {
		var so = {
			callback: callback,
			_time: that.time + _time,
			_repeat: 1
		};

		tasks.push(so);
		return so;
	}

	/**
	 *	@method onEvery
	 *	@memberof Timer.prototype
	 *	@description Invokes the callback repeatedly overtime. All time values in ms.
	 * 	
	 *	@param {Number} interval - how often to invoked the function. It can be an array of two elements specyfing a min/max range
	 *	@param {Number} time - when to start (i.e. delay, counted from 'now' i.e from when this method is called)
	 *	@param {Number} callback - the callback to be invoked
	 *	@param {Number} repeat - how many times to repeat. If ommited or -1 will repeat infinitely
	 *				0 will never invoke the function (in fact it won't even be added)
	 *
	 *	@returns {Object} an object that can be later used to remove the task.
	 */
	this.onEvery = function(_interval, _time, callback, _repeat) {

		if(_repeat === 0) return;
		
		var so = {
			callback: callback,
			_time: that.time + _time,
			_interval: _interval,
			_repeat: _repeat || -1

		};

		tasks.push(so);
		return so;
	}

	/**
	 *	@method off
	 *	@memberof Timer.prototype
	 *	@description Remove a scheduled task.
	 *
	 *	@param {Object} so - Object referencing the callback. 
	 *	<p>DO NOT PASS the original callback to this function (you'll get a warning if you do).
	 *	Instead you need to pass the object returned from onAt or onEvery. 
	 */
	this.off = function(so) {

		if(so instanceof Function) {
			var m = 'You are probably using the callback directly to remove it.\n';
			m += 'You should use the object returned from onAt or onEvery instead.';
			console.warn(m);
			console.warn(so);
			return;
		}

		if(so == null) {
			return;
		}

		var i = tasks.indexOf(so);
		if(i > -1) {
			tasks.splice(i, 1);
			return true;
		} else {
			return false;
		}
	}

	/**
	 *	@method clearTasks
	 *	@memberof Timer.prototype
	 *	@description Remove all tasks scheduled using onAt or onEvery
	 */
	this.clearTasks = function() {
		tasks.length = 0;
	}

	if(autostart) {
		that.start();
	}
}

/** 
 *	@member global
 *	@memberof Timer
 *	@static
 *
 *	@description A global static instance of a Timer for simple use cases.
 */
Timer.global = new Timer(true, true);


/* --- --- [Value] --- --- */

/**
 *	@class Value
 *
 *	@description <p>Value is an object that hold a property. 
 *
 *	<p>Properties are great to keep track of the state of on object. 
 *	For example "how many times the spaceship has been hit" or 
 *	"what is the current section on a website" or a lot of other things.
 *
 *	<p>A simple property can do the job well, example: "spaceship.numHits" is a number
 *	that increases each time the spacehip has been hit by enemy lasers. 
 *	
 *	<p>Usually there will be several objects in each application that will need 
 *	to do something whenever this value changes. To make this possible each of those
 *	objects would need to implement some sort of loop or timer and check the value of
 *	this property at regular intervals.
 *
 *	<p>This is where the Value object comes in handy. It keeps the value of the property
 *	in it's own property (called 'value') but, using the object observer pattern, 
 *	each time this value changes, it will send out a notification to every
 *	registered listener.
 *
 *	<p>The Value object works best with primitive values, especially Numbers. 
 *	But it can hold any object as value.
 *
 *	@param {Object} v - the initial value to set
 *
 *	@example

// sets the value to 1
var health = new Value(1);

health.on(function(current, last) {
	console.log('The value of health is', current);
	console.log('The previous value was', last);
	console.log('Current value can also be accessed from', health.value);
});

// value changed, the listener will be invoked
health.value = 2;

// value stays the same, the listener won't be invoked
health.value = 2;

 */

/*
 *	Also read this http://www.html5rocks.com/en/tutorials/es7/observe/
 */
var Value = function(_value, noInitCallback) {

	var that = this, 
		value = _value, 
		last = null;
	
	var min = null, max = null, wrap = false;

	var observers = [];

	that.observers = function() {
		return observers;
	}

	/**
	 *	@method on
	 *	@memberof Value.prototype
	 *
	 *	@param {Function} callback - the callback to invoke whenever the value changes. 
	 *	The callback function will receive up to 3 arguments. First is the current value, 
	 *	second is the last value (if there was any, null otherwise). Third is a custom param (see below).
	 *
	 *	@param {Function} test - a test function to check if value changed. If the value is a Object, 
	 *	some of it's properties might chnage and this function allows to inject the logic that will
	 *	decide whether the entire value should be considered "chnaged" or not. See example below.
	 *
	 *	@param {Object} param - a parameter to pass to the callback on each change. It will be passed as 3rd parameter.
	 *
	 *	@param {Boolean=} noInitCallback - if this is set explicitely to true, the callback will not be invoked immediately
	 *	on registration. Otherwise the callback is always called immediately, so that any state can be adjusted to the current
	 *	value.
	 *
	 *	@description sets the value property of thie Value to whatever is passed as parameter. 
	 *	Same as saying <code>someValue.value = v;</code> but this method can be useful when chaining. 
	 */
	that.on = function(callback, test, param) {

		if(observers.indexOf(callback) > -1) return;

		var o = callback;
		o.test = test;
		o.param = param;

		// Fire the callback initially so that all values/flags of the subscriber can be adjusted at startup
		if(!noInitCallback && (!o.test || o.test(value, last))) o(value, last, param);

		observers.push(o);
		return o;
	}


	/**
	 *	@method threshold
	 *	@memberof Value.prototype
	 *
	 *	@param {Number} min - the low value of the range of the threshold. It can be null, in this case there won't be a low value to the threshold.
	 *	@param {Number} max - the high value of the range of the threshold. It can be null, in this case there won't be a high value to the threshold.
	 *
	 *	@description Similar to on, but the callback will only be invoked when the value crosses a certain threshold and it's value is within a range.
	 */
	that.threshold = function(callback, min, max, param, noInitCallback) {
	
		var test;

		if(min != null && max != null) {
			test = function(c, l) { return (c >= min && l < min) || (c < max && l >= max); }
			if(_value >= min && _value < max && !noInitCallback) callback(_value);
		} else if(min != null && max == null) {
			test = function(c, l) { return (c >= min && l < min); }
			if(_value >= min && !noInitCallback) callback(_value);
		} else if(min == null && max != null) {
			test = function(c, l) { return (c < max && l >= max); }
			if(_value < max && !noInitCallback) callback(_value);
		}

		

		return that.on(callback, test, param, true);
	}

	/**
	 *	@method off
	 *	@memberof Value.prototype
	 *	@param {Function} callback - the callback that was originally passed to <code>on</code>.
	 *	@description Removes the callback from the list of listeners for this value.
	 */
	that.off = function(callback) {
		var i = observers.indexOf(callback);
		if(i > -1) observers.splice(i, 1);
	}

	/**
	 *	@method range
	 *	@memberof Value.prototype
	 *	@param {Number} _min - minimum value (inclusive)
	 *	@param {Number} _max - minimum value (inclusive)
	 *	@param {Number} _wrap - if true if value goes over max or below min it will be wrapped, otherwise it will clamped to min, max.
	 *
	 *	@description This method allows to add minumim and maximum allowed value to the Value object. Mostly useful for numbers, if
	 *	we need to make sure the value will not go over a certain threshold.
	 */
	that.range = function(_min, _max, _wrap) {
		min = _min;
		max = _max;
		wrap = _wrap;
		return that;
	}

	/**
	 *	@method set
	 *	@memberof Value.prototype
	 *	@param {Object} v
	 *	@description sets the value property of thie Value to whatever is passed as parameter. 
	 *	Same as saying <code>someValue.value = v;</code> but this method can be useful when chaining.
	 */
	that.set = function(v) {
		that.value = v;
		return that;
	}

	var changed = function() {
		var o;
		for(var i = 0, n = observers.length; i < n; i++) {
			o = observers[i];
			if(!o.test || o.test(value, last)) {
				o(value, last, o.param);
			}
		}
	}

	Object.defineProperty(this, 'value', {

		get: function() { 
			return value; 
		},

		set: function(n) { 
			if(min != null && max != null) {
				if(n < min) {
					wrap ? n = n % (max+1) : n = min;
					if(wrap) while(n < min) n += (max+1);
				}

				if(n > max) {
					wrap ? n = n % (max+1) : n = max;
					if(wrap) while(n < min) n += (max+1);
				}
			}

			if(n == value) return;

			last = value;
			value = n; 
			changed();
			// setTimeout(changed, 0);
		}

	});

	Object.defineProperty(this, 'last', {
		get: function() { 
			return last; 
		},
	});
}



/* --- --- [Application] --- --- */

/**
 *	@namespace Application
 */
var Application = (function() {

	var app = {};
	var router;

	/**
	 *	@member {Object} flags
	 *	@memberof Application
	 *	@static
	 */	
	app.flags = {};

	var fs = document.location.search.substring(1).split('&');
	fs.forEach(function(f) {
		var ff = f.split('=');
		app.flags[ff[0]] = parseFloat(ff[1]);
	});

	/**
	 *	@member {Trigger} start
	 *	@memberof Application
	 *	@static
	 */
	app.start = new Trigger();

	/**
	 *	@member {Trigger} resize
	 *	@memberof Application
	 *	@static
	 */
	app.resize = new Trigger();

	/**
	 *	@member {Value} route
	 *	@memberof Application
	 *	@static
	 */
	app.route = new Value({
		parts: []
	}, true);
	
	/**
	 *	@function init
	 *	@memberof Application
	 *	@static
	 */
	app.init = function(params) {

		params = params || {};

		if(!params.dontPrintVersion) {
			console.log('%cMalibu v' + 
				Framework.version + 
				' b' + Framework.build + 
				' (history:' + !params.disableHistoryAPI + ')'
				, 'background: #ff3600; color: #ffdede; padding: 4px 10px 4px 10px');
		}

		var r = {
			width: 0,
			height: 0,
			aspect: 0,
			orientation: -1,
			event: null
		}

		window.addEventListener('resize', function(e) {
			r.width = window.innerWidth;
			r.height = window.innerHeight;
			r.aspect = r.width / r.height;
			r.orientation = window.orientation;
			r.event = e;
			app.resize.trigger(r);
		});

		// window.addEventListener('orientationchange', function(e) {
		// 	app.resize.trigger(e);
		// });	

		router = HistoryRouter(app, params);
		router.init();	

		app.start.trigger();
	}
	
	return app;

})();




/* --- --- [Keyframes] --- --- */

var Keyframes = (function() {

	var r = {}, style;

	var lazyInit = function() {
		style = document.createElement("style");
		document.head.appendChild(style);
	}

	r.add = function(name, selectors) {

		if(!style) lazyInit();

		var r = '';

		for(var s in selectors) {
			r += s + '% { ' + selectors[s] + ' } ';
		}

		var rp = '@-' + Simplrz.prefix.lowercase + '-keyframes ' + name + ' {' + r + '}';;
		style.appendChild(document.createTextNode(rp));

		var rn = '@keyframes ' + name + ' {' + r + '}';;
		style.appendChild(document.createTextNode(rn));

		return name;
	}

	return r;

})();

/* --- --- [domExtend/DomExtend] --- --- */

/**
 *	@namespace DomExtend
 */
var DomExtend = (function() {

	var that = {};

	/**
	 *	@method create
	 *	@memberof DomExtend
	 *	@static
	 *	@param {string} tag - the name of the tag to create
	 *	@description Created a HTMLElement of type defined by the tag. It first calls <code>document.createElement(tag)</code> 
	 *	and the extends this element with DomExtend functionality.
	 */
	that.create = function(tag, cssclass) {
		var e = document.createElement(tag);
		if(cssclass) e.classList.add(cssclass);
		that.extend(e);
		return e;
	};

	/**
	 *	The equivalent of <code>document.querySelector</code>. It extends the object
	 *	with DomExtend functionality before returning the result.
	 *
	 *	@method select
	 *	@memberof DomExtend
	 *	@static
	 *	@param {string} sel - the CSS selector to query
	 *	@param {HTMLElement=} element - the HTML element to query on, defaults to document 
	 */
	that.select = function(sel, element) {
		var e = (element || document).querySelector(sel);
		if(e && !e.ext) that.extend(e);
		return e;
	};

	/**
	 *	The equivalent of <code>document.querySelectorAll</code>. It extends the objects
	 *	with DomExtend functionality before returning the result and it returns them as regular Array (yay!)
	 *
	 *	@method select
	 *	@memberof DomExtend
	 *	@static
	 *	@param {string} sel - the CSS selector to query
	 *	@param {HTMLElement=} element - the HTML element to query on, defaults to document 
	 */
	that.selectAll = function(sel, element) {
		var es = (element || document).querySelectorAll(sel);
		var nes = es.length, r = [];
		for(var i = 0; i < nes; i++) {
			var e = es[i]
			if(!e.ext) e = that.extend(e);
			r.push(e);
		}
		return r;
	};

	/**
	 *	@method extend
	 *	@memberof DomExtend
	 *	@static
	 *	@param {HTMLElement} element - the tag to extend
	 *	@description adds the .ext property to the element, with all the DomExtend functionality. This method should be rarely used and if you 
	 *	find yourself using it a lot, you need to rethink the code. All element selected with EXT.select or element.ext.select 
	 *	or created with EXT.create will be already extended.
	 */
	that.extend = function(element) {

		if(element.ext) return element;

		var ext = {};

		/**
		 *	The equivalent of <code>element.querySelector</code>. It extends the object
		 *	with DomExtend functionality before returning the result.
		 *
		 *	@method select
		 *	@memberof DomExtend.prototype
		 *	@param {string} sel - the CSS selector to query
		 */
		ext.select = function(sel) {
			return that.select(sel, element);
		};

		/**
		 *	The equivalent of <code>element.querySelectorAll</code>. It extends the objects
		 *	with DomExtend functionality before returning the result and it returns them as regular Array (yay!)
		 *
		 *	@method select
		 *	@memberof DomExtend.prototype
		 *	@param {string} sel - the CSS selector to query
		 */
		ext.selectAll = function(sel) {
			return that.selectAll(sel, element);
		};

		/**
		 *	@method detach
		 *	@memberof DomExtend.prototype
		 *	@description Safely removes the element from it's parent node. It is the same as saying 
		 *	element.parentNode.removeChild(element) but will not throw an error if parentNode is null.
		 */
		ext.detach = function() {
			var p = element.parentNode;
			if(!p) return;
			p.removeChild(element);
		};

		/**
		 *	@method attachTo
		 *	@memberof DomExtend.prototype
		 *	@description Safely attaches the element to a parent node. It is the same as saying 
		 *	parent.appednChild(element) but will not throw an error if child is already added to parent.
		 */
		ext.attachTo = function(parent) {
			if(element.parentNode == parent) return;
			else parent.appendChild(element);
		}

		// Add State related functions (see State.js for details)
		if(window.ExtState) ExtState(ext, element);

		// Add Transform related functions (see Transform.js for details)
		if(window.ExtTransform) ExtTransform(ext, element);

		// Add Transition related functions (see Transition.js for details)
		if(window.ExtTransition) ExtTransition(ext, element); 

		// Add Animation related functions (see Transition.js for details)
		if(window.ExtAnimation) ExtAnimation(ext, element, that); 

		ext.element = element;
		element.ext = ext;
		return element;
	};

	window.EXT = that;

	return that;

})();

/* --- --- [domExtend/State] --- --- */

var ExtState = function(ext, element) {

	var cc = function(p) {
		return p.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
	}

	ext.data = {};

	/**
	 *	@method show
	 *	@memberof DomExtend.prototype
	 *	@param {string} [display=block] the CSS property value to use.
	 *	@description Sets the display CSS property of the object to the display type specified in the argument. Defaults to "block".
	 */
	ext.show = function(display) {
		element.style.display = display || element.ext.__defaultDisplay || "block";
	};

	/**
	 *	@method hide
	 *	@memberof DomExtend.prototype
	 *	@description Sets the display CSS property of the object to "none".
	 */
	ext.hide = function() {
		var d = ext.readCss('display');
		element.ext.__defaultDisplay = d == 'none' ? 'block' : d;
		element.style.display = "none";
	};

	/**
	 *	@method toggle
	 *	@memberof DomExtend.prototype
	 *	@description Toggle the display CSS between "none" and "block".
	 */
	ext.toggle = function(show, display) {
		if(show) ext.show(display);
		else ext.hide();
	};

	/**
	 *	@method visible
	 *	@memberof DomExtend.prototype
	 *	@description Returns true if the CSS display property is set to none on this element.
	 */	
	ext.visible = function() {
		return ext.readCss('display') != "none";
	};

	/**
	 *	@method on
	 *	@memberof DomExtend.prototype
	 *	@description Equivalent of element.addEventListener but shorter and has a special touch handler for 'click' events.
	 */	
	ext.on = function(event, callback, useCapture) {
		// if(Simplrz.touch && event == 'click') {
		// 	callback.___thProxy = Util.handleTap(element, callback);
		// 	return callback.___thProxy;
		// } else 
		if(event == 'doubleclick') {
			callback.___dcProxy = Util.handleDC(element, callback);
			return callback.___dcProxy;
		} else {
			return element.addEventListener(event, callback, useCapture);
		}
	}

	/**
	 *	@method off
	 *	@memberof DomExtend.prototype
	 *	@description Equivalent of element.removeEventListener but shorter and works witht the special touch handler for 'click' events.
	 */	
	ext.off = function(event, callback, useCapture) {
		// if(callback.___thProxy) {
		// 	Util.clearTapHandler(element, callback.___thProxy);
		// 	callback.___thProxy = null;
		// } else 
		if(callback.___dcProxy) {
			// callback.___dcProxy.clear = null;
			Util.clearDCHandler(element, callback.___dcProxy);
		} else {
			return element.removeEventListener(event, callback, useCapture);	
		}
		
	};

	/**
	 *	@method readCss
	 *	@memberof DomExtend.prototype
	 *
	 *	@param {string} property - the name of the CSS property
	 *	@param {Boolean} notCalculated - if true, grabs the value directly from the style property of the object.
	 *
	 *	@description <p>Returns true if the value of a CSS property, fetched using computed styles.
	 *	<p>The CSS values of the object can be defined in multiple stylesheets, so it's not straightforward
	 *	to read them - i.e. in most cases just saying ex. <code>var d = element.style.display</code> will not return 
	 *	expected results. 
	 *	<p>This method uses computed styles to fetch the actual CSS value of a property.
	 */	
	ext.readCss = function(property, notCalculated) {
		if(notCalculated) {
			return element.style[property]; 
		} else {
			var s = getComputedStyle(element);
			if(!s) element.style[property]; // Bug in Firefox - this will be null if in iframe and it's set to display:none
			else return s.getPropertyValue(property);
		}
	}

	/**
	 *	@method bg
	 *	@memberof DomExtend.prototype
	 *	@description Loads and sets a backgroung image for the element. Passing the onLoad function allows to make 
	 *	animated transitions (ex. fade in) when the background images are loaded. 
	 *
	 *	@param {string} path - the path to the image
	 *	@param {Function} onLoad - the load callback to be exectued. It is called after the image was loaded but before
	 *	it has been set as background image.
	 */
	ext.bg = function(path, onLoad) {

		if(onLoad) {
			var i = new Image();
			i.addEventListener('load', function() {
				onLoad(element, i);
				element.style.backgroundImage = 'url(' + path + ')';
			});
			i.src = path;
		} else {
			element.style.backgroundImage = 'url(' + path + ')';
		}
	}
};












/* --- --- [domExtend/Transform] --- --- */

var ExtTransform = function(ext, element) {

	var force2d = false;

	var zeroRect = { width: 0, height: 0, top: 0, left: 0 };

	/**
	 *	@method rect
	 *	@memberof DomExtend.prototype
	 *	@description Returns the screen position and dimensions of the element. 
	 *
	 *	@returns {Object} An object with 4 properties:
	 *	left, top, width, height.
	 */	
	ext.rect = function() {
		// IE10 tends to throw and "unspecified error" here, so handle
		// the exception and just return a zero rect to avoid further damage
		try {
			return element.getBoundingClientRect();
		} catch(e) {
			console.log(e.stack);
			return zeroRect;
		}
	};

	/**
	 *	@method width
	 *	@memberof DomExtend.prototype
	 *	@description Shorthand for element.ext.rect().width 
	 */
	ext.width = function(v) {
		if(v) {
			element.style.width = v + "px";
			return v;
		} else {
			return ext.rect().width;
		}
	};

	/**
	 *	@method height
	 *	@memberof DomExtend.prototype
	 *	@description Shorthand for element.ext.rect().height 
	 */
	ext.height = function(v) {
		if(v) {
			element.style.height = v + "px";
			return v;
		} else {
			return ext.rect().height;
		}
	};

	/**
	 *	@member x
	 *	@memberof DomExtend.prototype
	 *	@description The x position of the element. It is not the absolute position of the element on the screen.
	 *	It always starts with 0 and only relates to the offset by which this element has been programatically moved
	 *	using the element.ext.transform function.
	 */
	ext.x = 0;

	/**
	 *	@member y
	 *	@memberof DomExtend.prototype
	 *	@description The y position of the element. It is not the absolute position of the element on the screen.
	 *	It always starts with 0 and only relates to the offset by which this element has been programatically moved
	 *	using the element.ext.transform function.
	 */
	ext.y = 0;

	/**
	 *	@member z
	 *	@memberof DomExtend.prototype
	 *	@description The z position of the element. It is not the absolute position of the element on the screen.
	 *	It always starts with 0 and only relates to the offset by which this element has been programatically moved
	 *	using the element.ext.transform function.
	 */
	ext.z = 0;

	/**
	 *	@member rotX
	 *	@memberof DomExtend.prototype
	 *	@description The x rotation of the element in DEGREES. It is not the absolute rotation of the element on the screen.
	 *	It always starts with 0 and only relates to the offset by which this element has been programatically rotated
	 *	using the element.ext.transform function.
	 */
	ext.rotX = 0;

	/**
	 *	@member rotY
	 *	@memberof DomExtend.prototype
	 *	@description The y rotation of the element in DEGREES. It is not the absolute rotation of the element on the screen.
	 *	It always starts with 0 and only relates to the offset by which this element has been programatically rotated
	 *	using the element.ext.transform function.
	 */
	ext.rotY = 0;

	/**
	 *	@member rotZ
	 *	@memberof DomExtend.prototype
	 *	@description The z rotation of the element in DEGREES. It is not the absolute rotation of the element on the screen.
	 *	It always starts with 0 and only relates to the offset by which this element has been programatically rotated
	 *	using the element.ext.transform function.
	 */
	ext.rotZ = 0;

	/**
	 *	@member scaleX
	 *	@memberof DomExtend.prototype
	 *	@description The x scale of the element. It is not the absolute scale of the element on the screen.
	 *	It always starts with 1 and only relates to the offset by which this element has been programatically scaled
	 *	using the element.ext.transform function.
	 */
	ext.scaleX = 1;

	/**
	 *	@member scaleY
	 *	@memberof DomExtend.prototype
	 *	@description The y scale of the element. It is not the absolute scale of the element on the screen.
	 *	It always starts with 1 and only relates to the offset by which this element has been programatically scaled
	 *	using the element.ext.transform function.
	 */
	ext.scaleY = 1;

	/**
	 *	@member scaleZ
	 *	@memberof DomExtend.prototype
	 *	@description The z scale of the element. It is not the absolute scale of the element on the screen.
	 *	It always starts with 1 and only relates to the offset by which this element has been programatically scaled
	 *	using the element.ext.transform function.
	 */
	ext.scaleZ = 1;

	ext.setX = function(v) { ext.x = v; return ext; };
	ext.setY = function(v) { ext.y = v; return ext; };
	ext.setZ = function(v) { ext.z = v; return ext; };

	ext.transformToString = function(values) {
		values = values || ext;

		var t = "";

		if(values.x) t += "translateX(" + values.x + "px) ";
		if(values.y) t += "translateY(" + values.y + "px) ";
		if(Simplrz.css3d && !force2d) t += "translateZ(" + values.z + "px) ";
		
		if(values.rotX && Simplrz.css3d) t += "rotateX(" + values.rotX + "deg)  ";
		if(values.rotY && Simplrz.css3d) t += "rotateY(" + values.rotY + "deg)";
		if(values.rotZ && Simplrz.css3d) t += "rotateZ(" + values.rotZ + "deg) ";
		else if(values.rotZ) t += "rotate(" + values.rotZ + "deg) ";
		
		if(values.scaleX != 1) t += "scaleX(" + values.scaleX + ") ";
		if(values.scaleY != 1) t += "scaleY(" + values.scaleY + ") ";
		if(values.scaleZ != 1 && Simplrz.css3d) t += "scaleZ(" + values.scaleZ + ")";
	
		return t;
	};


	/**
	 *	@method transform
	 *	@memberof DomExtend.prototype
	 *	@description <p>Applies the transformation values to the elements CSS transform property. The values can either be set via
	 *	the member variables: x, y, z, rotX, rotY, rotZ, scaleX, scaleY, scaleZ or canbe passed as parameter to this function. Please see
	 *	the documentation for the indivdual properties above to see what they do (thought it should be pretty obvious based on their names :)</p>
	 *
	 *	<p>Please also read carefully <a href='http://www.html5rocks.com/en/tutorials/speed/high-performance-animations/'>this article</a>.
	 * 
	 *	@param {Object=} values An object literal containing the properties to be affected. The naming convention is the same as 
	 *	the transformtion properties of DomExtend objects, i.e. x, y, z, rotX, rotY, rotZ, scaleX, scaleY, scaleZ.
	 *
	 * @example
// First select the object
var e = EXT.select('#someElement');

// Move the element 10px to the right of it's original position
e.ext.x = 10;
e.ext.transform();

// Move the element 10px down from it's original position
e.ext.transform({ y: 10 });

// Increase the elements x position by 20
e.ext.x += 20;
e.ext.transform();

// Rotate the element in 3d around the y axis by 45deg
// (note that for 3d to work, you need to setup the persepctive on the parent element in CSS)
e.ext.transform({ rotY: 45 });

	 */
	ext.transform = function(values) {
		if(values) {
			for(var i in values) {
				ext[i] = values[i];
			}
		}

		var t = ext.transformToString(ext, force2d);
		element.style[Simplrz.prefixedProp('transform')] = t;
		element.style["transform"] = t;
	};
};










/* --- --- [domExtend/Transition] --- --- */

var ExtTransition = function(ext, element) {

	var events = {
		'transition': 'transitionEnd',
		'Moz': 'transitionend',
		'O': 'oTransitionEnd',
		'Webkit': 'webkitTransitionEnd',
		'Ms': 'MSTransitionEnd'
	};

	var trEvent = events[Simplrz.prefix.js];
	var TR = "transform";

	var now = function() {
		return new Date().getTime();
	}

	ext.createTransition = function() {

		var transition = {};
		var tr = [], ts = [];
		var cb, numTrans;
		var startTime, maxTime = 0, finalized;

		var onEnded = function(e) {
			numTrans--;
			if(numTrans <= 0) {
				var t = now() - startTime;
				if(t >= maxTime) {
					finalize();
				} else if(!finalized) {
					// console.log("Transition early end > ", t, maxTime);
					setTimeout(finalize, t);
					finalized = true;
				}
			}
		};

		var finalize = function() {
			transition.clear();
			if(cb) cb();
		}

		var setValues = function(vals) {
			var nv = vals.length;

			for(var i = 0; i < nv; i++) {
				var p = vals[i][0], v = vals[i][1];
				if(p == TR) ext.transform(v);
				else element.style[p] = v;
			}

			return transition;
		};

		function propToCss(str) {
			return str.replace(/([A-Z])/g, function(letter) { return '-' + letter.toLowerCase(); });
		}

		transition.add = function(property, to, time, ease, delay) {
			maxTime = Math.max(maxTime, time);
			ease = ease || Util.cssEase.ease;
			delay = delay || 0;
			tr.push([propToCss(property), time+'ms', ease, delay+'ms'].join(' '));
			ts.push([property, to]);

			return transition;
		}

		transition.trs = function(values, time, ease, delay) {
			maxTime = Math.max(maxTime, time);
			ease = ease || Util.cssEase.ease;
			delay = delay || 0;
			tr.push([Simplrz.prefix.css + "transform", time+'ms', ease, delay+'ms'].join(' '));
			ts.push([TR, values]);

			return transition;
		}

		transition.clear = function() {
			element.removeEventListener(trEvent, onEnded);
			tr = [];
			ts = [];
			element.style[Simplrz.prefix.js + "Transition"] = "";
			element.style["transition"] = "";
		}

		transition.start = function(callback) {
			cb = callback;
			numTrans = ts.length;

			// force repaint
			var w = element.offsetWidth;

			element.addEventListener(trEvent, onEnded);
			startTime = now();
			finalized = false;
			element.style[Simplrz.prefix.js + "Transition"] = tr;
			element.style["transition"] = tr;
			setValues(ts);

			return transition;
		};

		transition.then = function(callback) {
			var t = ext.createTransition();

			var c = function() {
				callback();
				t.start();
			}

			transition.start(c);

			return t;
		}

		return transition;

	};

	/** 
	 *	@method transition
	 *	@memberof DomExtend.prototype
	 *	@description Creates and starts a CSS transition animation on the element.
	 *
	 *	@param {Object} properties - the properties to animate, See examples below.
	 *	@param {Number} time - the duration of the animation in milliseconds
	 *	@param {string} ease - the ease. See Util.cssEase for list of easing functions available.
	 *	@param {Number=} delay - the delay before the animation starts in milliseconds, defaults to 0
	 *	@param {Function=} callback - the function to be invoked when the animation is finished
	 *
	 *	@example
// Animate the opacity property
element.style.opacity = 0;
element.ext.transtion({ opacity: 1 }, 1000, 'ease');

// Animate the opacity with custom easing and listen for when the animation is over
element.style.opacity = 0;
element.ext.transtion({ opacity: 1 }, 1000, Util.cssEase.quadIn, 0, function() {
	console.log('Animation is over!');
});

// Animate the x, y position and z rotation 

// 1. Define start values 
// If this is omitted the transtions will start 
// from the current state of the object.
element.ext.x = 0;
element.ext.y = 0;
element.ext.rotZ = 0;
element.ext.transform();

// 2. Start the animation
// Note that the transform values are passed as object, 
// not as properties of the "properties" argument
element.ext.transition({
	transform: {
		x: 100, y: 100, rotZ: 20
	}
}, 1000, 'ease');
	 */
	ext.transition = function(properties, time, ease, delay, callback) {
		var t = ext.createTransition();

		for(var p in properties) {
			var v = properties[p];
			if(p == TR) t.trs(v, time, ease, delay);
			else t.add(p, v, time, ease, delay);
		}

		t.start(callback);
		return t;
	}
};




/* --- --- [domExtend/Animation] --- --- */

var ExtAnimation = function(ext, element, globalExt) {

	var events = {
		'animation': 'animationend',
		'Moz': 'animationend',
		'O': 'oanimationend',
		'Webkit': 'webkitAnimationEnd',
		'Ms': 'MSAnimationEnd'
	};

	var animStrigify = function(anim) {
		return [
			anim.name, 
			anim.duration + 's', 
			anim.ease, 
			anim.delay + 's', 
			anim.count, 
			anim.direction, 
			anim.fillMode//, 
			// anim.playState // doesn't work on Safari 8.0, but it's not very useful anyway
		].join(' ');
	}

	// animation: name duration timing-function delay iteration-count direction fill-mode (play-state - not-inplemented);
	var createAnimation = function(name, duration, ease, delay) {
		var a = {
			name: name,
			duration: duration || 1,
			ease: ease || 'ease',
			delay: delay || 0,
			count: 1,
			direction: 'normal',
			fillMode: 'backwards'//,
			// playState: 'running'
		};

		a.setTime = function(t) {
			a.time = t;
			return a;
		}

		a.setDelay = function(t) {
			a.delay = t;
			return a;
		}

		return a;
	}

	globalExt.createAnimation = createAnimation;
	ext.createAnimation = createAnimation;

	ext.animate = function(anim, callback, dontClear) {

		var a;

		if(anim instanceof Array) {
			var aa = [];
			anim.forEach(function(e) { aa.push(animStrigify(e)); });
			a = aa.join(', ');
		} else {
			a = animStrigify(anim);
		}

		var eventName = events[Simplrz.prefix.js];

		if(element._onEnded) element.removeEventListener(eventName, element._onEnded);

		element._onEnded = function() {
			element.removeEventListener(eventName, element._onEnded);

			if(dontClear == null) {
				element.style[Simplrz.prefix.js + "Animation"] = '';
				element.style["animation"] = '';
			}

			if(callback) callback();
		}


		element.style[Simplrz.prefix.js + "Animation"] = "";
		element.style["animation"] = "";

		setTimeout(function() {
			if(ext.show) ext.show();
			element.addEventListener(eventName, element._onEnded);
			element.style[Simplrz.prefix.js + "Animation"] = a;
			element.style["animation"] = a;
		}, 0);
	}
};

/* --- --- [FrameImpulse] --- --- */

/**
 *	@namespace FrameImpulse
 *
 *	@description <p>A utility to handle <code>requestAnimationFrame</code> loops. It really only exists to eliminate a  common but hard debug problem: 
 *	since RaF is sort of a recurent function, sometimes the code can accidentally start the loop twice (or even more times). This has diastrous 
 *	conseuences for perofrmance, but it is not easy to spot at all.</p>
 *
 	<p>With <code>FrameImpulse</code> you will not get into this kind of trouble easily.</p>
 *
 *	@example
var render = function() {
  // Do some rendering logic in here
}

// When the loop needs to be activated
FrameImpulse.on(render);

// ...and when it needs to stop
FrameImpulse.off(render);
 */
var FrameImpulse = (function() {

    var vendors = ['webkit', 'moz'];

	var listeners = [], numListeners = 0, toRemove = [], numToRemove;
	var lastTime = 0;

	var provider = window;

	var r = {};

    // for(var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
    //     window.requestAnimationFrame = window[vendors[i] + 'RequestAnimationFrame'];
    // }

    // if (!window.requestAnimationFrame) {
    //     window.requestAnimationFrame = function(callback) {
    //         var currTime = new Date().getTime();
    //         var timeToCall = Math.max(0, 16 - (currTime - lastTime));
    //         var id = window.setTimeout(function() { 
    //         	callback(currTime + timeToCall); 
    //         }, timeToCall);
    //         lastTime = currTime + timeToCall;
    //         return id;
    //     };
    // }

	var run = function(deltaTime) {
		provider.requestAnimationFrame(run);

		if(numListeners == 0) return;
		
		for(var i = 0; i < numListeners; i++) {
			listeners[i].call(deltaTime);
		}

		if(numToRemove > 0) {
			var indexToRemove = [];
			for (var i = listeners.length - 1; i >= 0; i--) {
				for (var j = 0; j < toRemove.length; j++) {
					if (listeners[i] === toRemove[j])
						indexToRemove.push(i);
				};
			};

			for (var i = 0; i < indexToRemove.length; i++) {
				listeners.splice(indexToRemove[i], 1);
			};

			numListeners = listeners.length;
			toRemove = [];
			numToRemove = 0;
		}		
	}

	/**
	 *	@method on
	 *	@memberof FrameImpulse
	 *	@static
	 *
	 *	@param {Function} callback - the function used as callback for the listener
	 *	@description Adds a listener to be called on every frame. The cool thing about this function, 
	 *	is that the same function is added twice, it will not be called twice later on. However, this 
	 *	does not work with anonymous functions, so we suggest to never use anonnymous functions with this.
	 */
	r.on = function(f) {
		if(listeners.indexOf(f) > -1) { return; }
		listeners.push(f);
		numListeners = listeners.length;
		// console.log("FrameImpulse > new listener > total :", numListeners);
	}

	/**
	 *	@method off
	 *	@memberof FrameImpulse
	 *	@static
	 *
	 *	@param {Function} callback - the function used as callback for the listener. 
	 *	Needs to be the same function as passed to the <code>on()</code> when it was being registered.
	 *	@description Removes a listener to be called on every frame
	 */
	r.off = function(f) {
		

		// At this point we think the "late" removal patttern was more harmful than helpful, so it's gone.

		// if(listeners.indexOf(f) == -1) { return; }
		// toRemove.push(f);
		// numToRemove = toRemove.length;

		var i = listeners.indexOf(f);
		if(i == -1) return;
		listeners.splice(i, 1);
		numListeners = listeners.length;
	}

	/**
	 *	@method getListeners
	 *	@memberof FrameImpulse
	 *	@static
	 *
	 *	@description Returns a list of all currently registered functions. Useful for debugging.
	 */
	r.getListeners = function() {
		return listeners;
	}

	r.setProvider = function(p) {
		provider = p || window;
	}

	run();
	return r;

})();

/* --- --- [HistoryRouter] --- --- */

/**
 *	@class HistoryRouter
 *
 *	@description <p>A router that handles browser/app history. 
 *	Works with either the History API or just internally within the app.</p>
 *	<p>In most cases - NOT TO BE used directly, it is used internally by {@link Application} instead.</p>
 */
var HistoryRouter = function (app, params) {

	var disableHistoryAPI = (params && params.disableHistoryAPI) || !Simplrz.history;

	var rootUrl = document.location.protocol + '//' + (document.location.hostname || document.location.host);
	if(document.location.port) rootUrl += ":" + document.location.port;
	app.navigate = new Trigger();
	app.hijackLinks = new Trigger();

	Application.history = [];

	var setBase = function() {
		var base = document.querySelector('base');
		base = (base && base.getAttribute('href')) ? base.getAttribute('href') : '/';

		// In case base href is a full URL with protocol & domain
		// - this gets just the part we need
		var prs = document.createElement('a');
		prs.href = base;
		base = prs.pathname;

		if(base == '/') base = '';
		if(base[base.length-1] == '/') base = base.substring(0, base.length - 1);
		app.baseUrl = base;
	}

	var hijackLinks = function (element) {
		var allLinksSelector = 'a[href]';
		var allLinks = (element || document).querySelectorAll(allLinksSelector);
		
		allLinks = Array.prototype.slice.call(allLinks);

		if(element && element.nodeName.toLowerCase() == "a") {
			allLinks.unshift(element);	
		}

		for (var i = 0; i < allLinks.length; i++) {
			var link = allLinks[i];

			var url = link.getAttribute('href');
			var target = link.getAttribute('target');
			var hj = link.getAttribute('data-hj');

			if(url == null || url.indexOf(':') > -1 || target == '_blank' || hj == "no") {
				// Skip absolute URLs, those that have no URL, a _blank target 
				// and those that are explicitely set to not be hijacked
				// (this is done by adding an attribute like this: data-hj='no')
				continue;
			}
			
			if (!link.hijacked) {
				link.hijacked = true;

				link.originalHref = link.getAttribute('href') || "";
				link.hijackedHref = app.baseUrl + "/" + link.getAttribute('href');

				if(link.hijackedHref.indexOf('//') == 0) link.hijackedHref = link.hijackedHref.substring(1); 
				// normalize the URL, so it doesn't start with double slashes

				var cb = function (e) {
					if(e) e.preventDefault();
					app.navigate.trigger(this.hijackedHref);
				}

				link.removeHijack = function() {
					link.removeEventListener('click', cb);
					link.hijacked = false;
				}

				link.hijackCallback = cb;
				link.addEventListener('click', cb);
			}
		}
	};

	var notify = function(href) {

		var r = {};

		if(disableHistoryAPI)  {

			r.route = href || '';
			
		} else {

			var qs = document.location.href.indexOf('?');
			var hs = document.location.href.indexOf('#');

			var route = document.location.href;

			if(qs > -1) route = route.substring(0, qs);
			if(hs > -1) route = route.substring(0, hs);
			r.route = route.substring(rootUrl.length + 1 + app.baseUrl.length);			

		}

		r.parts = r.route.split('/');

		// Get rid of all trailing stuff
		while(r.parts[0] == '') r.parts.shift();
		while(r.parts[r.parts.length - 1] == '') r.parts.pop();

		r.lastPart = r.parts[r.parts.length - 1];

		if(r.route == app.route.value.route) return;
		Application.history.push(r);
		app.route.value = r;
	}

	if(!disableHistoryAPI) {
		window.addEventListener('popstate', function(e) {
			notify();
		});
	}

	app.hijackLinks.on(hijackLinks);

	var navCond;

	// https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onbeforeunload
	var bu = function(e) {
		var m = navCond();
		e.returnValue = m;
		return m;
	}

	app.setNavigateCondition = function(c) {
		navCond = c;
		window.addEventListener('beforeunload', bu);
	}

	app.clearNavigateCondition = function() {
		window.removeEventListener('beforeunload', bu);
		navCond = null;
	}

	app.navigate.on(function(href) {

		var n = function() {
			history.pushState(null, null, href);
			notify();
		}

		if(navCond) navCond(n, href);
		else n();
	});

	return {

		init: function () {
			setBase();
			if (!disableHistoryAPI) {
				notify();
			} else {
				var home, qs = document.location.search;

				if(params && params.home) home = params.home;

				if(qs.indexOf('=') > -1) {
					var aq = qs.substring(1).split('&');
					aq.forEach(function(q) {
						if(q.indexOf('id=') > -1) {
							home = q.split('=')[1];
						}
					});
				} else if(qs) {
					home = qs.substring(1);
				}

				// console.log('home', qs, home);

				notify(home || '');
			}
		}
	}
};

/* --- --- [Loader] --- --- */

/**
 *	@namespace Loader
 *
 *	@description A very (very) simple AJAX loader.
 */
var Loader = {

	/**
	 *	@method loadText
	 *	@memberof Loader
	 *	@static
	 *
	 *	@description Loads a text file through AJAX
	 *
	 *	@param {string} path - the path to the file, absolute or relative
	 *	@param {Function} onLoadedFunc - callback for when the file is loaded. The contents of the file in string format will be passed to this callback as argument.
	 */
	loadText: function(path, onLoadedFunc, formData, progressCallback){

		var request = new XMLHttpRequest();
		request.open(formData ? "POST" : "GET", path, true);
		request.withCredentials = true;

		request.addEventListener('readystatechange', function(e) {
			if (request.readyState == 4) {

				if(!request.responseText) {
					console.warn('empty response'); // , path);
					return;
				}
				
				onLoadedFunc(request.responseText);
			}
		});

		if(progressCallback) {
			request.addEventListener('progress', function(e) {
				if(e.lengthComputable) {
					var t = e.loaded / e.total;
					progressCallback(t, e.loaded, e.total);
				}
			});
		}

		request.send(formData);
	},

	/**
	 *	@method loadJSON
	 *	@memberof Loader
	 *	@static
	 *
	 *	@description Loads a JSON file through AJAX
	 *
	 *	@param {string} path - the path to the file, absolute or relative
	 *	@param {Function} onLoadedFunc - callback for when the file is loaded. The contents of the file in JS object format will be passed to this callback as argument.
	 *	@param {FormData} formData - data to be sent via POST
	 *	@param {Function} progressCallback - callback for loading progress
	 *	@param {Function} errorCallback - callback called in case JSON parse fails
	 */
	loadJSON: function(path, onLoadedFunc, formData, progressCallback){
		Loader.loadText(path, function(text) {
			// try {
			onLoadedFunc(JSON.parse(text));
			// } catch(e) {
			// 	if(Loader.onError) Loader.onError(e);
			// 	else console.error(e);
			// }
		}, formData, progressCallback);
	}
};










/* --- --- [VirtualScroll] --- --- */

/**
 *	@namespace VirtualScroll
 *
 *	@description World Famous VirtualScroll &copy;
 *
 *	<p>
 *	<a href='http://www.everyday3d.com/blog/index.php/2014/08/18/smooth-scrolling-with-virtualscroll/'>How to use</a><br>
 *	<a href='http://work.bartekdrozdz.com/malibu/test/wheel-simple.html'>Simple example</a><br>
 *	<a href='http://work.bartekdrozdz.com/malibu/test/wheel-multi.html'>Paralax example</a>
 *	</p>
 *
 *	<p>Within the context of the DomExtend functionality, VirtualScroll works best with the element.ext.transform() function.</p>
 *
 *	@example
var onSroll = function(e) {
  // Do some scrolling action logic in here
}

// When the loop needs to be activated
VirtualScroll.on(onScroll);

// ...and when it needs to stop
VirtualScroll.off(onScroll);
 *
 *	@example
// Using VS with DomExtend

var scroll = 0, targetScroll = 0;

// typically the limit of scrolling will be defined by the height of the object minus the height of the window
var MAX_SCROLL = element.ext.height() - window.innerHeight;

var onScroll = function(e) {
	targetScroll += e.deltaY;

	// Clamp the scroll to limit values
	targetScroll = Math.max(0, targetScroll);
	targetScroll = Math.min(MAX_SCROLL, targetScroll);
}

var onFrame = function() {
	// Add some easing
	scroll += (targetScroll - scrol) * 0.1; 

	// Apply the scroll value
	element.ext.transform({ y: -scroll });
}

VirtualScroll.on(onScroll);
FrameImpulse.on(onFrame);
 */
var VirtualScroll = (function() {
	
		var vs = {};
	
		var numListeners, listeners = [], initialized = false;
	
		// [ These settings can be customized with the options() function below ]
		// Mutiply the touch action by two making the scroll a bit faster than finger movement
		var touchMult = 2;
		// Firefox on Windows needs a boost, since scrolling is very slow
		var firefoxMult = 15;
		// How many pixels to move with each key press
		var keyStep = 120;
		// General multiplier for all mousehweel including FF
		var mouseMult = 1;
	
		var bodyTouchAction;
	
		var hasWheelEvent = 'onwheel' in document;
		var hasMouseWheelEvent = 'onmousewheel' in document;
		var hasTouch = 'ontouchstart' in document;
		var hasKeyDown = 'onkeydown' in document;
	
		// var hasTouchWin = navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1;
		var hasPointer =   !!window.navigator.pointerEnabled;
		var hasPointerMS = !!window.navigator.msPointerEnabled;
	
		var isFirefox = navigator.userAgent.indexOf('Firefox') > -1;
	
		var isTouchDown = false;
	
		// console.log('hasTouch', hasTouch);
		// console.log('hasPointer', hasPointer);
		// console.log('hasPointerMS', hasPointerMS);
	
		var event = {
			y: 0,
			x: 0,
			deltaX: 0,
			deltaY: 0,
			startX: 0,
			startY: 0,
			
			multiTouch: false,
			y2: 0,
			x2: 0,
			startX2: 0,
			startY2: 0,
	
			originalEvent: null,
			source: null
		};
	
		vs.on = function(f) {
			if(!initialized) {
				initListeners(document); 
				initialized = true;
			}
	
			var i = listeners.indexOf(f);
			if(i != -1) return;
	
			listeners.push(f);
			numListeners = listeners.length;
		}
	
		/**
		 *	@method options
		 *	@memberof VirtualScroll
		 *	@static
		 *
		 *	@param {Object} opt - object literal containing one or more options from the list above, specified as properties.
		 *
		 *	@description Sets custom parameters to the VirtualScroll (globally). The following options are supported:
		 *
		 *	<ul>
		 *	<li>touchMult (default: 2) - mutiply the touch action to make the scroll a faster/slower than finger movement</li>
		 *	<li>firefoxMult (defailt: 15)- Firefox on Windows needs a boost, since scrolling is very slow</li>
		 *	<li>keyStep (default: 120) - specified how many pixels to move with each key press</li>
		 *	<li>mouseMult (default: 1) - general multiplier for all mousehweel events including FF</li>
		 *	</ul>
		 */
		vs.options = function(opt) {
			keyStep = opt.keyStep || 120;
			firefoxMult = opt.firefoxMult || 15;
			touchMult = opt.touchMult || 2;
			mouseMult = opt.mouseMult || 1;
		}
	
		vs.off = function(f) {
			var i = listeners.indexOf(f);
			if(i == -1) return;
	
			listeners.splice(i, 1);
			numListeners = listeners.length;
			if(numListeners <= 0) {
				destroyListeners(document);
				initialized = false;
			}
		}
	
		var lockEvent = function(e) { e.preventDefault(); };
	
		/**
		 *	@method lockTouch
		 *	@memberof VirtualScroll
		 *	@static
		 *
		 *	@description For VirtualScroll to work on mobile, the default swipe-to-scroll behavior needs to be turned off. 
		 *	This function will take care of that, however it's a failt simple mechanism - see in the source code, linked below.
		 */
		vs.lockTouch = function() {
			document.addEventListener('touchmove', lockEvent, { passive: false });
		}
	
		/**
		 *	@method unlockTouch
		 *	@memberof VirtualScroll
		 *	@static
		 *
		 *	@description Restores all touch events to default. Useful for hybrid pages that have some VS and some regular scrolling content.
		 */
		vs.unlockTouch = function() {
			document.removeEventListener('touchmove', lockEvent, { passive: false });
		}
	
		/**
		 *	@method lockWheel
		 *	@memberof VirtualScroll
		 *	@static
		 *
		 *	@description Lock the wehll event so that interacting with the wheel (or touch pad) does not fire the scroll event.
		 */
		vs.lockWheel = function() {
			if(hasWheelEvent) document.addEventListener("wheel", lockEvent, { passive: false });
			if(hasMouseWheelEvent) document.addEventListener("mousewheel", lockEvent, { passive: false });
		}
	
		/**
		 *	@method unlockWheel
		 *	@memberof VirtualScroll
		 *	@static
		 *
		 *	@description Unlock the wheel and make interacting with it correctly scroll the page.
		 */
		vs.unlockWheel = function() {
			if(hasWheelEvent) document.removeEventListener("wheel", lockEvent, { passive: false });
			if(hasMouseWheelEvent) document.removeEventListener("mousewheel", lockEvent, { passive: false });
		}
	
		var notify = function(e, s) {
			event.x += event.deltaX;
			event.y += event.deltaY;
			event.originalEvent = e;
			event.source = s;
	
			for(var i = 0; i < numListeners; i++) {
				listeners[i](event);
			}
		}
	
		var onWheel = function(e) {
			// In Chrome and in Firefox (at least the new one)
			event.deltaX = e.wheelDeltaX || e.deltaX * -1;
			event.deltaY = e.wheelDeltaY || e.deltaY * -1;
	
			// for our purpose deltamode = 1 means user is on a wheel mouse, not touch pad 
			// real meaning: https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent#Delta_modes
			if(isFirefox && e.deltaMode == 1) {
				event.deltaX *= firefoxMult;
				event.deltaY *= firefoxMult;
			} 
	
			event.deltaX *= mouseMult;
			event.deltaY *= mouseMult;
	
			notify(e, "wheel");
		}
	
		var onMouseWheel = function(e) {
			// In Safari, IE and in Chrome if 'wheel' isn't defined
			event.deltaX = (e.wheelDeltaX) ? e.wheelDeltaX : 0;
			event.deltaY = (e.wheelDeltaY) ? e.wheelDeltaY : e.wheelDelta;
	
			notify(e, "wheel");	
		}
	
		var onTouchStart = function(e) {
			var t = (e.targetTouches) ? e.targetTouches[0] : e;
			event.startX = t.pageX;
			event.startY = t.pageY;
	
			if(e.targetTouches && e.targetTouches.length > 1) {
				t = e.targetTouches[1];
				event.startX2 = t.pageX;
				event.startY2 = t.pageY;
				event.multiTouch = true;
			} else {
				event.multiTouch = false;
			}
	
			isTouchDown = true;
		}
	
		var onTouchEnd = function() {
			isTouchDown = false;
			event.multiTouch = false;
		}
	
		var onTouchMove = function(e) {
			if(!isTouchDown) return;
			// e.preventDefault(); // < This needs to be managed externally
			var t = (e.targetTouches) ? e.targetTouches[0] : e;
	
			if(!event.startX) event.startX = t.pageX;
			if(!event.startY) event.startY = t.pageY;
	
			event.x = t.pageX;
			event.y = t.pageY;
	
			event.deltaX = (t.pageX - event.startX) * touchMult;
			event.deltaY = (t.pageY - event.startY) * touchMult;
			
			event.startX = t.pageX;
			event.startY = t.pageY;
	
			if(e.targetTouches && e.targetTouches.length > 1) {
				t = e.targetTouches[1];
				event.multiTouch = true;
				
				if(!event.startX2) event.startX2 = t.pageX;
				if(!event.startY2) event.startY2 = t.pageY;
	
				event.x2 = t.pageX;
				event.y2 = t.pageY;
			} else {
				event.multiTouch = false;
			}
	
			notify(e, "touch");
		}
	
		var onKeyDown = function(e) {
			// 37 left arrow, 38 up arrow, 39 right arrow, 40 down arrow
			event.deltaX = event.deltaY = 0;
			switch(e.keyCode) {
				case 37:
					event.deltaX = -keyStep;
					break;
				case 39:
					event.deltaX = keyStep;
					break;
				case 38:
					event.deltaY = keyStep;
					break;
				case 40:
					event.deltaY = -keyStep;
					break;
			}
	
			notify(e, "key");
		}
	
		var wheelOpts = { passive: true };
	
		var initListeners = function(element) {
	
			if(hasWheelEvent) element.addEventListener("wheel", onWheel, wheelOpts);
			if(hasMouseWheelEvent) element.addEventListener("mousewheel", onMouseWheel, wheelOpts);
	
			if(hasTouch) {
				element.addEventListener("touchstart", onTouchStart);
				element.addEventListener("touchmove", onTouchMove);
				element.addEventListener("touchend", onTouchEnd);
			}
			
			if(hasPointer || hasPointerMS) {
				bodyTouchAction = element.body.style.touchAction;
				element.body.style.touchAction = "none";
				element.addEventListener(hasPointerMS ? "MSPointerDown" : "PointerDown", onTouchStart, true);
				element.addEventListener(hasPointerMS ? "MSPointerMove" : "PointerMove", onTouchMove, true);
				element.addEventListener(hasPointerMS ? "MSPointerUp" : "PointerUp", onTouchEnd, true);
			}
	
			if(hasKeyDown) element.addEventListener("keydown", onKeyDown);
		}
	
		var destroyListeners = function(element) {
			if(hasWheelEvent) element.removeEventListener("wheel", onWheel, wheelOpts);
			if(hasMouseWheelEvent) element.removeEventListener("mousewheel", onMouseWheel, wheelOpts);
	
			if(hasTouch) {
				element.removeEventListener("touchstart", onTouchStart);
				element.removeEventListener("touchmove", onTouchMove);
				element.removeEventListener("touchend", onTouchEnd);
			}
			
			if(hasPointer || hasPointerMS) {
				element.body.style.touchAction = bodyTouchAction;
				element.removeEventListener(hasPointerMS ? "MSPointerDown" : "PointerDown", onTouchStart, true);
				element.removeEventListener(hasPointerMS ? "MSPointerMove" : "PointerMove", onTouchMove, true);
				element.removeEventListener(hasPointerMS ? "MSPointerUp" : "PointerUp", onTouchEnd, true);
			}
	
			if(hasKeyDown) element.removeEventListener("keydown", onKeyDown);
		}
	
		vs.trackFrame = function(frame) {
			initListeners(frame);
		}
	
		vs.untrackFrame = function(frame) {
			destroyListeners(frame);
		}
	
		return vs;
		
	})();

/* --- --- [Gesture] --- --- */

/**
 * 	@class Gesture
 *
 *	@param {Object=} options - object holding settings (see above)
 *
 *	@description 
 *
 *	<p>A simple touch (or click/drag) gesture recognition class.</p>
 *
 *	<p>Works with touch gesture, mouse clik/drag gestures and key press (cursor keys), detects swipes in 4 directions.</p>
 *
 *	<p>For advanced scenarios <a href='http://hammerjs.github.io/'>Hammer.js</a> can be used instead.</p>
 *
 *	<p>Options include:
 *	<ul>
 *		<li>maxTime - how long before swipe is not considered a swipe (default 300ms)</li>
 *		<li>minDistance - how much must the user move to consider this a swipe (default 30px)</li>
 *		<li>tolerance - how far off vertical or horizontal axis is considered as swipe 
 *				default: 0.1, don't make it larger than 0.25 (i.e. 45deg)</li>
 *		<li>noKeyboard - if set tu true, key listeners will not be activated 
 *				(use if cursor keys are used for something else and there's a conflict)</li>
 *	</ul>
 *	</p>
 *
 *	@example
var g = new Gesture();
g.swipeUp.on(function() {
  console.log("User swiped up!");
});
 */
var Gesture = function(options) {

	options = options || {};

	var that = this;
	var cl;

	var isTouch = 'ontouchstart' in document;
	var downEvent = isTouch ? 'touchstart' : 'mousedown';
	var moveEvent = isTouch ? 'touchmove' : 'mousemove';
	var upEvent =   isTouch ? 'touchend' : 'mouseup';

	/**
	 *	@member {Trigger} swipeUp
	 *	@memberof Gesture.prototype
	 *
	 *	@description Triggered when a "swipe up" gesture is detected
	 */	
	this.swipeUp = new Trigger();

	/**
	 *	@member {Trigger} swipeDown
	 *	@memberof Gesture.prototype
	 *
	 *	@description Triggered when a "swipe down" gesture is detected
	 */	
	this.swipeDown = new Trigger();

	/**
	 *	@member {Trigger} swipeLeft
	 *	@memberof Gesture.prototype
	 *
	 *	@description Triggered when a "swipe left" gesture is detected
	 */	
	this.swipeLeft = new Trigger();

	/**
	 *	@member {Trigger} swipeRight
	 *	@memberof Gesture.prototype
	 *
	 *	@description Triggered when a "swipe right" gesture is detected
	 */	
	this.swipeRight = new Trigger();

	var tolerance = options.tolerance || 0.1;

	var start = { x:0, y:0 }, 
		delta = { x: 0, y: 0 },
		startTime = 0,
		maxTime = options.maxTime || 300, minDistance = options.minDistance || 30; 
		minDistance = minDistance * minDistance; // square it for faster math

	var onStart = function(e) {
		e = isTouch ? e.targetTouches[0] : e;
		start.x = e.pageX;
		start.y = e.pageY;
		delta.x = 0;
		delta.y = 0;
		startTime = new Date().getTime();
	}

	var onMove = function(e) {
		e = isTouch ? e.targetTouches[0] : e;
		delta.x = e.pageX - start.x;
		delta.y = e.pageY - start.y;
	}

	var onStop = function(e) {
		var ds = delta.x * delta.x + delta.y * delta.y;
		var dt = new Date().getTime() - startTime;
		var t = tolerance;

		if(dt > maxTime) return;
		if(ds < minDistance) return;

		var a = Math.atan2(delta.y, delta.x) / Math.PI;
		// up = -0.5, down = 0.5, left = 1, right = 0
		if(a > -0.5 - t && a < -0.5 + t) that.swipeUp.trigger();
		if(a >  0.5 - t && a <  0.5 + t) that.swipeDown.trigger();
		if(a >  0.0 - t && a <  0.0 + t) that.swipeRight.trigger();
		if(a < -1.0 + t || a >  1.0 - t) that.swipeLeft.trigger();
	}

	var onKeyDown = function(e) {
		// 37 left arrow, 38 up arrow, 39 right arrow, 40 down arrow
		delta.x = delta.y = 0;
		switch(e.keyCode) {
			case 39:
				that.swipeLeft.trigger();
				break;
			case 37:
				that.swipeRight.trigger();
				break;
			case 40:
				that.swipeUp.trigger();
				break;
			case 38:
				that.swipeDown.trigger();
				break;
		}
	}

	/**
	 *	@method create
	 *	@memberof Gesture.prototype
	 *
	 *	@description registers all necessary listeners. 
	 *	This is done automatically in the constructor, 
	 *	so it doesn't need to be called, unless destroy()
	 *	was called before and we want to reuse the object.
	 */	
	this.create = function() {
		(options.element || document).addEventListener(downEvent, onStart);
		document.addEventListener(moveEvent, onMove);
		document.addEventListener(upEvent, onStop);
		if(!options.noKeyboard) document.addEventListener("keydown", onKeyDown);
	}

	/**
	 *	@method destroy
	 *	@memberof Gesture.prototype
	 *
	 *	@description deregisters all listeners
	 */	
	this.destroy = function() {
		(options.element || document).removeEventListener(downEvent, onStart);
		document.removeEventListener(moveEvent, onMove);
		document.removeEventListener(upEvent, onStop);
		if(!options.noKeyboard) document.removeEventListener("keydown", onKeyDown);
	}

	this.create();
}

/* --- --- [Template] --- --- */

var Template = function() {

	var that = this;

	this.content;

	var selectorCache;

	this.set = function(content) {
		if(content instanceof HTMLElement) {
			that.content = EXT.extend(content.cloneNode(true));
		} else {
			var df = document.createElement('div');
			df.innerHTML = content ? content.trim() : "";
			that.content = EXT.extend(df.firstChild);
		}

		selectorCache = {}; 
		
		return that;
	}

	this.wrap = function(element) {
		that.content = EXT.extend(element);
		selectorCache = {}; 
		return that;
	} 

	this.select = function(sel) {
		if(selectorCache[sel]) {
			return selectorCache[sel];
		} else {
			var e = that.content.ext.select(sel);
			if(!e) throw "Selector not found: " + sel;
			selectorCache[sel] = e;
			return e;
		}
	}

	this.clearCache = function() {
		selectorCache = {}; 
	}

	this.hide = function(sel) {
		that.select(sel).style.display = 'none';
	}

	this.attachTo = function(parent, onAdded) {

		if(!that.content) return;

		that.content.ext.attachTo(parent);
		if(onAdded) {
			// http://jsfiddle.net/CAewW/2/
			requestAnimationFrame(function() {
				requestAnimationFrame(onAdded);
			});
		}
	}

	this.detach = function(onBeforeRemove) {

		if(!that.content) return;

		if(onBeforeRemove) {
			onBeforeRemove(function() {
				that.content.ext.detach();
			});
		} else {
			that.content.ext.detach();
		}
	}

	this.updateText = function(sel, text) {
		console.warn('Template.updateText is deprecated, use Template.text instead');
		that.select(sel).innerHTML = text;
	}

	this.text = function(sel, text) {
		that.select(sel).innerHTML = text;
	}

	this.appendText = function(sel, text) {
		that.select(sel).innerHTML += text;
	}

	this.append = function(sel, elem) {
		that.select(sel).appendChild(elem);
	}

	this.clone = function() {

	}

	this.insertList = function(sel, list, template) {
		list.forEach(function(e) {

			if(template) {
				var t = template.content.cloneNode(true);
				t.innerHTML = e;
				that.append(sel, t);
			} else {
				that.appendText(sel, e);
			}
			
		});
	}
}

/* --- --- [Util] --- --- */

/**
 *	@namespace Util
 */
var Util = {

	/**
	 *	@method fullbleed
	 *	@memberof Util
	 *	@static
	 *	@param {HTMLElement} element - the node to scale to fullbleed 
	 *	conserving the aspect ratio. It should be either image or video. 
	 *	
	 *	@description <p>This function calculates the size and position of the element
	 *	so that it cover the entire area of it's container (or the whole viewport).
	 *	It does a similar thing to what <code>background-size: cover;</code> does for 
	 *	background images in CSS. Most useful with videos, but can be used with 
	 *	img tags as well.
	 *
	 *	<p>This function does not transform the element, 
	 *	it only returns an array of values to use. 
	 *	To actually resize/reposition the element, use {@link Util.resizeTo}.
	 *
	 *	@param {Number=} w - the width of the container, defaults to window.innerWidth
	 *	@param {Number=} h - the height of the container, defaults to window.innerHeight
	 *
	 *	@returns {Array} values to use to scale fullscreen in that order: 
	 *	left, top, width, height.
	 *
	 *	@example
var video = EXT.create('video'); 
// same as document.createElement('video');

var f = Util.fullbleed(video);
Util.resizeTo(video, f);

// ..or in shorthand form:
Util.resizeTo(video, Util.fullbleed(video));
	 */
	fullbleed: function(element, w, h) {
		var isVideo = element.videoWidth > 0;

		var sw = w || window.innerWidth,
			sh = h || window.innerHeight,
			vw = isVideo ? element.videoWidth : element.naturalWidth,
			vh = isVideo ? element.videoHeight : element.naturalHeight;
		// IE doesnt return correct values for width.height of images but naturalWidth/Height works just fine

		var sa = sw / sh;
		var va = vw / vh;

		var vx, vy, vcw, vch;

		// large aspect = wide screen, small aspect = tall screen
		// element aspect < screen aspect = height needs overflow
		// element apsect > screen aspect = width needs overflow

		if(va < sa) {
			vx = 0;
			vcw = sw;
			vch = vh / vw * sw;
			vy = (vch - sh) * -0.5;
		} else if(va > sa) {
			vy = 0;
			vch = sh;
			vcw = vw / vh * sh;
			vx = (vcw - sw) * -0.5;
		} else {
			vx = vy = 0, vcw = sw, vch = sh;
		}

		return [vx, vy, vcw, vch];
	},

	/**
	 *	@method fullContain
	 *	@memberof Util
	 *	@static
	 *	@param {HTMLElement} element - the node to scale to fullContain 
	 *	conserving the aspect ratio. It should be either image or video. 
	 *	
	 *	@description <p>This function calculates the size and position of the element
	 *	so that it cover the maximum area of it's container (or the whole viewport)
	 *	without cropping the image/video itself. It does a similar thing to what 
	 *	<code>background-size: contain;</code> does for 
	 *	background images in CSS. Most useful with videos, but can be used with 
	 *	img tags as well.
	 *
	 *	<p>This function does not transform the element, 
	 *	it only returns an array of values to use. 
	 *	To actually resize/reposition the element, use {@link Util.resizeTo}.
	 *
	 *	@param {Number=} w - the width of the container, defaults to window.innerWidth
	 *	@param {Number=} h - the height of the container, defaults to window.innerHeight
	 *
	 *	@returns {Array} values to use to scale fullscreen in that order: 
	 *	left, top, width, height.
	 *
	 *	@example
var video = EXT.create('video'); 
// same as document.createElement('video');

var f = Util.fullContain(video);
Util.resizeTo(video, f);

// ..or in shorthand form:
Util.resizeTo(video, Util.fullContain(video));
	 */
	fullContain: function(element, w, h) {
		var isVideo = element.videoWidth > 0;

		var w = window.innerWidth;
		var h = window.innerHeight;
		var iw = isVideo ? element.videoWidth :  element.width;
		var ih = isVideo ? element.videoHeight : element.height;
		var scrRatio = w  / h;
		var imgRatio = iw / ih;
		var sx, sy, sw, sh;

		// contain
		if(scrRatio > imgRatio) {
			sy = 0;
			sh = h;
			sw = (h / ih) * iw;
			sx = (w - sw) * 0.5;
		} else if(scrRatio < imgRatio) {
			sx = 0;
			sw = w;
			sh = (w / iw) * ih;
			sy = (h - sh) * 0.5;
		} else {
			sx = 0, sy = 0, sw = w, sh = h;
		}

		return[sx, sy, sw , sh];
	},

	/**
	 *	@method resizeTo
	 *	@memberof Util
	 *	@static
	 *
	 *	@description resizes and moves the element to a give size and position, 
	 *	by applying values to it's CSS top/left/width and height properties. Assumes
	 *	the element has a block display mode (or any other mode that works). 
	 *	Works best when the element has position absolute.
	 *
	 *	@param {HTMLElement} element - the element to resize
	 *	@param {Array} dimensions - the dimensions to use, typically as returned from
	 *	{@link Util.fullbleed} or {@link Util.fullContain}
	 */
	resizeTo: function(element, dimensions) {
		element.style.left = 	dimensions[0] + 'px';
		element.style.top = 	dimensions[1] + 'px';
		element.style.width = 	dimensions[2] + 'px';
		element.style.height = 	dimensions[3] + 'px';
	},

	/**
	 *	@method hexToRgb
	 *	@memberof Util
	 *	@static
	 *	@param {String} hex - the hex representation of the color (ex. #a2e5d9)
	 *	@returns {Object} and object with values r, g and b in 0-255 range
	 */
	hexToRgb: function(hex) {
		var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
		return result ? {
				r: parseInt(result[1], 16),
				g: parseInt(result[2], 16),
				b: parseInt(result[3], 16)
		} : null;
	},

	handleTap: function(element, callback) {

		var tapHandler = callback.___thProxy || (function() {

			var h = {};
			var minTime = 20000;
			var startTime;
			var minDistSq = 100;
			var sx, sy;
			var el = element;
			var cb = callback;

			h.click = function(e) {
				// e.preventDefault();
			} 

			h.touchStart = function(e) {
				// e.preventDefault();

				startTime = new Date().getTime();
				sx = e.targetTouches[0].pageX;
				sy = e.targetTouches[0].pageY;
			}

			h.touchEnd = function(e) {
				// e.preventDefault();

				var t = new Date().getTime() - startTime;

				var dx = e.changedTouches[0].pageX - sx;
				var dy = e.changedTouches[0].pageY - sy;
				var dsq = (dx*dx + dy*dy);

				if(t < minTime && dsq < minDistSq) cb.call(el, e);
			}

			return h;

		})();

		element.addEventListener("touchstart", tapHandler.touchStart);
		element.addEventListener("touchend", tapHandler.touchEnd);
		element.addEventListener("click", tapHandler.click);

		return tapHandler;
	},

	clearTapHandler: function(element, handler) {
		element.removeEventListener("touchstart", handler.touchStart);
		element.removeEventListener("touchend", handler.touchEnd);
		element.removeEventListener("click", handler.click);
	},

	handleDC: function(element, callback) {

		var dcHandler = callback.___dcProxy || (function() {

			var h = {};
			var el = element;
			var cb = callback;

			var t = Simplrz.touch;
			var minTime = t ? 300 : 200, minDist = t ? 12 : 5;
			var lastTime = 0, lastX = -minDist, lastY = -minDist;
			

			h.click = function(e) {

				var x = e.changedTouches ? e.changedTouches[0].pageX : e.pageX;
				var y = e.changedTouches ? e.changedTouches[0].pageY : e.pageY;

				e.pageX = x;
				e.pageY = y;

				var t = new Date().getTime();
				if(t - lastTime < minTime && x - lastX < minDist && y - lastY < minDist) {
					cb.call(el, e);
					lastTime = 0;
					lastX = -minDist;
					lastY = -minDist;
				} else {
					lastTime = t;
					lastX = x;
					lastY = y;
				}
			} 

			return h;

		})();

		element.addEventListener("click", dcHandler.click);
		return dcHandler;
	},

	clearDCHandler: function(element, handler) {
		element.removeEventListener("click", handler.click);
	},

	/**
	 *	@readonly
	 *	@enum {String}
	 *	@description A collection of easing curves to be used with 
	 *	CSS transitions or animations
	 *	@example
// Using easing with CSS transitions in EXT
var e = EXT.select('.someElement');
e.ext.transition({ opacity: 0 }, 300, Util.cssEase.easeInQuint);
	 */
	cssEase: {
		'ease': 'ease',
		/** Alias for 'ease' */
		'smoothstep': 'ease',
		'in': 'ease-in',
		'out': 'ease-out',
		'in-out': 'ease-in-out',
		'snap': 'cubic-bezier(0,1,.5,1)',
		'easeOutCubic': 'cubic-bezier(.215,.61,.355,1)',
		'easeInOutCubic': 'cubic-bezier(.645,.045,.355,1)',
		'easeInCirc': 'cubic-bezier(.6,.04,.98,.335)',
		'easeOutCirc': 'cubic-bezier(.075,.82,.165,1)',
		'easeInOutCirc': 'cubic-bezier(.785,.135,.15,.86)',
		'easeInExpo': 'cubic-bezier(.95,.05,.795,.035)',
		'easeOutExpo': 'cubic-bezier(.19,1,.22,1)',
		'easeInOutExpo': 'cubic-bezier(1,0,0,1)',
		'easeInQuad': 'cubic-bezier(.55,.085,.68,.53)',
		'easeOutQuad': 'cubic-bezier(.25,.46,.45,.94)',
		'easeInOutQuad': 'cubic-bezier(.455,.03,.515,.955)',
		'easeInQuart': 'cubic-bezier(.895,.03,.685,.22)',
		'easeOutQuart': 'cubic-bezier(.165,.84,.44,1)',
		'easeInOutQuart': 'cubic-bezier(.77,0,.175,1)',
		'easeInQuint': 'cubic-bezier(.755,.05,.855,.06)',
		'easeOutQuint': 'cubic-bezier(.23,1,.32,1)',
		'easeInOutQuint': 'cubic-bezier(.86,0,.07,1)',
		'easeInSine': 'cubic-bezier(.47,0,.745,.715)',
		'easeOutSine': 'cubic-bezier(.39,.575,.565,1)',
		'easeInOutSine': 'cubic-bezier(.445,.05,.55,.95)',
		'easeInBack': 'cubic-bezier(.6,-.28,.735,.045)',
		'easeOutBack': 'cubic-bezier(.175, .885,.32,1.275)',
		'easeInOutBack': 'cubic-bezier(.68,-.55,.265,1.55)'
	}

};







